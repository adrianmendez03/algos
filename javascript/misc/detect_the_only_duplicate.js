// You are given a list nums of length n + 1 picked from the range 1, 2, ..., n. By the pigeonhole principle, 
// there must be a duplicate. Find and return it. There is guaranteed to be exactly one duplicate.

// Bonus: Can you do this in \mathcal{O}(n)O(n) time and \mathcal{O}(1)O(1) space?

class Solution {
    solve(nums) {
        // const s = new Set()
        // for (let num of nums) {
        //     if (s.has(num)) {
        //         return num
        //     } 
        //     s.add(num)
        // }

        // nums = nums.sort((a, b) => a - b) 
        // for (let i = 0; i < nums.length - 1; i++) {
        //     if (nums[i] === nums[i + 1]) {
        //         return nums[i]
        //     }
        // }
    }
}